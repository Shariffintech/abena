{"ast":null,"code":"import * as React from \"react\";\nimport { computeRelativePath, isRoute, useCurrentRouteId, getRouteElementId } from \"../router/index.js\";\nimport { isString } from \"../utils/utils.js\";\n\nfunction isTransition(value) {\n  switch (value) {\n    case \"instant\":\n    case \"push\":\n    case \"fade\":\n      return true;\n\n    default:\n      return false;\n  }\n} // This includes the comma that separates the media type from the data.\n\n\nconst mediaType = \"framer/page-link,\";\n/**\n * @internal\n */\n\nexport function isFramerPageLink(value) {\n  return isString(value) && value.startsWith(`data:${mediaType}`);\n}\n/**\n * @internal\n */\n\nexport function createFramerPageLink() {\n  let targetId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const target = targetId ? targetId : \"none\";\n  const link = new URL(`data:${mediaType}${target}`);\n\n  for (const optionKey in options) {\n    link.searchParams.append(optionKey, options[optionKey]);\n  }\n\n  return link.href;\n}\n/**\n * @internal\n */\n\nexport function parseFramerPageLink(link) {\n  if (!isFramerPageLink(link)) return;\n\n  try {\n    const url = new URL(link);\n    const target = url.pathname.substring(mediaType.length);\n    const attributes = {};\n    let element;\n    url.searchParams.forEach((value, key) => {\n      if (key === \"element\") {\n        // The element attribute is lifted to the parsed result.\n        element = value;\n      } else if (key === \"transition\") {\n        if (!isTransition(value)) return;\n      }\n\n      attributes[key] = value;\n    });\n    url.searchParams.delete(\"element\");\n    return {\n      target: target === \"none\" ? null : target,\n      element: element === \"none\" ? null : element,\n      attributes\n    };\n  } catch {\n    return;\n  }\n}\n/** A regex that searches for html tags, and href values. */\n\nconst regex = /(<([a-z]+)(?:\\s+(?!href[\\s=])[^=\\s]+=(?:'[^']*'|\"[^\"]*\"))*)(?:(\\s+href\\s*=)(?:'([^']*)'|\"([^\"]*)\"))?((?:\\s+[^=\\s]+=(?:'[^']*'|\"[^\"]*\"))*>)/gi;\n/**\n * Escape html characters that would result in invalid paths.\n * https://www.30secondsofcode.org/js/s/escape-html\n */\n\nconst escapeHTML = str => str.replace(/[&<>'\"]/g, tag => ({\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"'\": \"&#39;\",\n  '\"': \"&quot;\"\n})[tag] || tag);\n/**\n * @internal\n */\n\n\nexport function replaceFramerPageLinks(rawHTML, getRoute, currentRouteId, pathVariables) {\n  return rawHTML.replace(regex, (original, pre1, tag, pre2, value1, value2, post) => {\n    if (tag.toLowerCase() !== \"a\") return original;\n    const pageLink = parseFramerPageLink(value1 || value2);\n    if (!pageLink || !pageLink.target) return original;\n    const targetRoute = getRoute(pageLink.target, pathVariables);\n    const currentRoute = getRoute(currentRouteId);\n    if (!isRoute(targetRoute) || !isRoute(currentRoute)) return original;\n    const targetPath = targetRoute.path;\n    const currentPath = currentRoute.path;\n    if (!targetPath || !currentPath) return original;\n    let attributes = ` ${\"data-framer-page-link-target\"\n    /* Page */\n    }=\"${pageLink.target}\"`;\n\n    if (pageLink.attributes.transition) {\n      attributes += ` ${\"data-framer-page-link-transition\"\n      /* Transition */\n      }=\"${pageLink.attributes.transition}\"`;\n    }\n\n    const elementId = getRouteElementId(targetRoute, pageLink.element ?? undefined);\n\n    if (elementId) {\n      attributes += ` ${\"data-framer-page-link-element\"\n      /* Element */\n      }=\"${pageLink.element}\"`;\n    }\n\n    let relativePath = computeRelativePath(currentPath, targetPath);\n\n    if (pathVariables) {\n      relativePath = relativePath.replace(/:(\\w+)/g, (_, key) => \"\" + pathVariables[key]);\n    }\n\n    return pre1 + pre2 + `\"${escapeHTML(relativePath + (elementId ? `#${elementId}` : \"\"))}\"` + attributes + post;\n  });\n}\n/**\n * @internal\n */\n\nexport function useLinkMatchesRoute(link) {\n  const currentRouteId = useCurrentRouteId();\n  if (!currentRouteId) return false;\n  const pageLink = parseFramerPageLink(link); // If we allowed page links to be active when they had an element, all page\n  // links that were to an element on the current page would always be active.\n  // We don't want that, so for now, we ignore links with elements. In future,\n  // maybe we can build a feature so that links to an element on the current\n  // page are only active when the element is in view.\n\n  return isFramerPageLink(link) && pageLink?.target === currentRouteId && !pageLink?.element;\n}\n/** @internal */\n\nexport const PathVariablesContext = React.createContext(undefined);","map":{"version":3,"mappings":"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","names":["React","computeRelativePath","isRoute","useCurrentRouteId","getRouteElementId","isString","isTransition","value","mediaType","isFramerPageLink","startsWith","createFramerPageLink","targetId","options","target","link","URL","optionKey","searchParams","append","href","parseFramerPageLink","url","pathname","substring","length","attributes","element","forEach","key","delete","regex","escapeHTML","str","replace","tag","replaceFramerPageLinks","rawHTML","getRoute","currentRouteId","pathVariables","original","pre1","pre2","value1","value2","post","toLowerCase","pageLink","targetRoute","currentRoute","targetPath","path","currentPath","transition","elementId","undefined","relativePath","_","useLinkMatchesRoute","PathVariablesContext","createContext"],"sources":["../../src/modules/framerPageLink.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}